#include "main.h"

//------------------------------------------------------------------------------
// объявляем переменные
//------------------------------------------------------------------------------
volatile uint16_t impuls,dlitelnost,knopkainkrement;
volatile uint8_t simvol,razr1,razr2,razr3,otrabotat,pwm,menu,nastroika_chastoti,otschet1,otschet2,zvuk;
volatile bool nazhatie_knop,yderzhanie_knop,pik,pusk,encoderminus,encoderplus;
//------------------------------------------------------------------------------
// сохраняем константы в память программ
//------------------------------------------------------------------------------
const uint16_t delitel [10]   PROGMEM =   {16000,1600,800,500,400,200};
const uint8_t razdelitel [10]  PROGMEM  =  {160,16,8,5,4,2};
const int8_t chastota [10]    PROGMEM  =  {1,10,20,32,40,80};
	
//------------------------------------------------------------------------------
// обработчики прерываний 
//------------------------------------------------------------------------------
ISR ( INT1_vect )                           // прерывания от энкодера
{
	if (ENCPOVOROT)                         // если второй пин энкодера уже сработал то мы поворачиваем в лево
	{
		switch (menu){                      // в зависимости от пункта меню где мы находимся  
			case 0:
			encoderminus = true;            // поднимаем флаг сработавшего энкодера
			piknut (1,50);                  // пикаем
			break;
			case 1:
			if (nastroika_chastoti > 0) nastroika_chastoti --;          // если настройка частоты больше 0 декрементируем 
			piknut (1,50);                                              // пикаем
			break;
			case 2:
			zvuk = 0;                                                   // звук = 0
			piknut (1,50);                                              // пикаем
			break;
		}
	}
	else                                        // если сработало прерывание от энкодера а второй пин еще не нажат то мы крутимся в право
	{
		switch (menu){                          // в зависимости от пункта меню где мы находимся  
			case 0:
			encoderplus = true;                 // поднимаем флаг сработавшего энкодер
			piknut (1,50);                      // пикаем 
			break;
			case 1:
			if (nastroika_chastoti < 5) nastroika_chastoti ++;      // если настройка частоты меньше 5 инкрементируем ее 
			piknut (1,50);                                          // пикаем 
			break; 
			case 2:
			zvuk = 1;                                               // звук = 0 
			piknut (1,50);                                          // пикаем 
			break;
		}
		
	}
}

ISR (TIMER0_OVF_vect){                                           // прерывание по переполнению таймер 0
	
	simvol ++;                                                   // инкремент символа
	switch (simvol)                                              // в зависимости от того какой символ 
	{
		case 1 :
		Q3ON;                                                    // выключаем транзистор 3 разряда (выключаем потому что там пнп и + это выключить)
		indikciya (razr3);                                       // вызываем функцию конфигурации выводов 7-сегментника в зависимости от цифры
		Q1OFF;                                                   // включаем транзистор 1 разряда 
		break;
		case 2 :
		Q1ON;
		indikciya (razr2);
		Q2OFF;
		break;
		case 3 :
		Q2ON;
		if (menu == 0 ) indikciya (razr1);                       // если мы в 0 меню показываем разряд
		if (menu == 1 ) indikciya ('H');                         // если мы в первом меню показываем букву Н
		if (menu == 2 ) indikciya ('S');                         // если мы во втором меню показываем букву S
		Q3OFF;
		break;
	}
	if (simvol == 3) simvol = 0;                                 // если символ стал равен трем обнулить его 
	
	if (KNOPKAENC){                                              // отслеживаем кнопку енкодера
		knopkainkrement ++;                                      // если нажата инкрементируем
		if (knopkainkrement >= 2100) knopkainkrement = 2100;      // если значение больше 2100 сделать 2100 для защиты от переполнения переменной
		if (knopkainkrement == 2000) piknut (1,500);             // если значение стало 2000 пикнуть, чтоб дать понять удержание кнопки
	}
	else                                                        // если нажатия нету
	{
		if (knopkainkrement >= 20 && knopkainkrement < 2000) {   // проверяем переменную кнопки на количество. если больше 20 и меньше 2000
			nazhatie_knop = true;                                // то это нажатие на кнопку
			piknut (1,50);                                       // пикнуть
		}
		
		if (knopkainkrement > 2000){                             // если переменная кнопки выше 2000
			yderzhanie_knop = true;                              // считаем это удержанием
		}
		knopkainkrement = 0;                                     // обнуляем переменную кнопки
	}
}
ISR (TIMER2_OVF_vect){                                          // прерывание по переполнению 2 таймера
	if (zvuk == 1) pik_pik ();                                  // если звук включен то обрабатываем функцию пиканья
	if (otschet1 >= 250) otschet1 = 250;                        // если отсчет больше 250 сделать 250 -  защита от переполнения
	otschet1 ++;                                                // плюсуем переменную отсчета
	if (otschet2 >= 250) otschet2 = 250;
	otschet2 ++;
}

int main(void)
{
	init();                                                      // инициаплизация
	nastroika_chastoti = EEPROM_read(1);                         // считываем переменную с еепром
	zvuk =  EEPROM_read(2);                                      // считываем вторую переменную из еепром
	ICR1 =  pgm_read_word_near(&(delitel [nastroika_chastoti])); // устанавливаем предел до которого считать в регистре шима
	pwm = 50;                                                    // начальное значение шим 50%
	for (;;)                                                     // бесконечный цикл
	{
		
		if (yderzhanie_knop){                                    // если поднят флаг удержание кнопки
			menu ++;                                             // переходим в следующий раздел меню
			if (menu == 3) {                                     // если меню = 3 (мы прошли все пункты) 
				menu = 0;                                        // обнуляем меню
				EEPROM_write(1, nastroika_chastoti);             // сохраняем в еепром частоту
				EEPROM_write(2, zvuk);                           // сохраняем режим звука
				nazhatie_knop = false;                           // сбрасываем нажатие кнопки если было
				pusk = false;                                    // сбрасываем пуск
			} 
			yderzhanie_knop = false;                             // сбрасываем удержание кнопки 
		}
		switch (menu)                                            // в зависимости от пункта меню
		{
			case 0:                                              // если мы в нулевом пункте меню 
			read_encoder ();                                     // считываем енкодер ( на флаг)
			if (nazhatie_knop) {                                 // если произошло нажатие на кнопку
				pusk = !pusk;                                    // инвертируем значение пуск
				nazhatie_knop = false;                           // сбрасываем нажатие кнопки
			}
			if (pusk){                                           // если пуск правда 
				LEDON;                                           // включаем светик
				GOOPWM;                                          // запускаем шим
				razbivaem_razryad (pwm);                         // пепедаем в функцию разбивки значение переменной шим
				OCR1A = pwm * pgm_read_byte_near(&(razdelitel [nastroika_chastoti]));       // в регистр шим ( при достижении этого значения сбросится выход) умножаем текущее значение шим на заранее записаное число (чтоб шаг был 1%)
			}
			if (!pusk){                                           // если пуск не правда
				LEDOFF;                                           // выключаем светик
				STOPPWM;                                          // останавливаем шим
				razbivaem_razryad (pwm);                          // пепедаем в функцию разбивки значение переменной шим
			}
			break;
			case 1:                                               // если мы в первом пункте меню 
			LEDOFF;                                               // выключаем светик
			STOPPWM;                                              // останавливаем шим
			razbivaem_razryad (pgm_read_byte_near (& chastota [nastroika_chastoti]));       // в функцию разбивки передаем значение из предустановок частоты шим
			ICR1 =  pgm_read_word_near(&(delitel [nastroika_chastoti]));                    // записываем в регистр новое значение до которого нужно считать
			break;
			case 2:                                                // если мы во втором пункте меню 
			LEDOFF;                                                // выключили светик
			STOPPWM;                                               // остановили шим
			razbivaem_razryad (zvuk);                              // показываем значение звука (активен или нет) 
			break;
		}
	}
	
}

void init (void){
	
	
	//--инициализируем прерывания -- //
	EICRA = 0x08;            // прерывания по спаду
	EIMSK = 0x02;	         // разрешить прерывания INT1
	//--инициализируем таймер T0-- //
	TIMSK0=0x01;            // включаем прерывания по переполнению
	TCCR0B=0x02;            // делитель тактовой частоты на 8
	//--инициализируем таймер T1-- //
	#ifdef INVERT_MOD
	TCCR1A = 0xC2;          // не инверсный режим
	#endif
	#ifndef NONINVERT_MOD
	TCCR1A = 0x82;          // инверсный режим
	#endif
	TCCR1B = 0x19;          // настройка быстрый шим и делитель на 1
	//--инициализируем таймер T2-- //
	TIMSK2 = 0x01;            // включаем прерывания по переполнению
	TCCR2B = 0x02;            // делитель тактовой частоты на 64
	
	DDRC = 0xBF;
	DDRD = 0xE3;
	DDRB = 0x03;
	PORTD = 0x1C;
	
	sei();                     // разрешаем прерывания
}
void razbivaem_razryad (unsigned int vhod_chislo)  // разбиваем число на 3 разряда
{
	razr1 = vhod_chislo/100;           // сотни
	razr2 = vhod_chislo%100/10;        // десятки
	razr3 = vhod_chislo%10;            // единицы
}
void pik_pik (void)                    // функция пиканья (без бутылки не разберешь) 
{
	if (pik) impuls ++;                       // если поднят флаг пик то плюсуем переменную
	if (impuls >= 10000) impuls = 10000;      // защита от переполнения
	if (otrabotat > 0) 	pik = true;           // если отработать больше 0 поднять флаг пиканья
	if (otrabotat == 0) {                     // если отработать = 0
		pik = false;                          // сбрасываем флаг пиканья
		impuls = 0;                           // обнуляем переменную счета
		BUZEROFF;                             // выключаем бузер
	}
	if (impuls == 1) BUZERON;                 // если переменная равна 1 включить бузер
	if (impuls == dlitelnost) BUZEROFF;       // если переменная равна длительности выключить бузер
	if (impuls == ((dlitelnost + 1) * 3)){    // если импульс равен длительности +1 и умноженой на 3 (+1 для того чтоб при нуле адекватно себя вело) (3 это во сколько раз пауза длинее импульса) 
		otrabotat --;                         // минусуем переменную
		impuls = 0;                           // сбрасываем в ноль счетчик
	}
}
void piknut (int kolichestvo, int dolgo)      // сюда передаем количество раз сколько нужно пикнуть и длительность пика
{
	otrabotat = kolichestvo;                  // просто переписываю это в другую переменную
	dlitelnost = dolgo;                       // и это тоже
}
void read_encoder (void)                      // функция чтения енкодера
{
	if(encoderplus && otschet1 <= 235)        // если поднят флаг вращения энкодера и таймер еще не досчитал до 235
	{
		otschet1 = 0;                         // сбрасываем таймер
		encoderplus = false;                  // сбрасываем флаг енкодера
		if (pwm < 95) pwm = pwm + PYAT;       // если значение переменной меньше 95 прибавляем по 5
	}
	if(encoderminus && otschet2 <= 235)       // тоже самое только в обратную сторону
	{
		otschet2 = 0;
		encoderplus = false;
		if (pwm > 5)pwm = pwm - PYAT;
	}
	if(encoderplus)                           // если поднят флаг енкодера 
	{
		otschet1 = 0;                         // сбрасываем таймер
		encoderplus = false;                  // сбрасываем флаг
		 if (pwm < 100) pwm ++;               // плюсуем переменную 
	}
	if (encoderminus)                         // тоже самое только в минус
	{
		otschet2 = 0;
		encoderminus = false;
		if (pwm > 0)pwm --;
	}
	
}
